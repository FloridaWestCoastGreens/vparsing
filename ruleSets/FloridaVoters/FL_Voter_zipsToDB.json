{
  "rule": "def tempfiles = []\ndef filecount = 0\ndef maxlines = 25000\ndef ln = System.getProperty('line.separator')\ndef tmpDir = System.getProperty(\"java.io.tmpdir\")\n\ndef importFolder = new File(\"${tmpDir}/Voters/Florida\")\nif(!importFolder.exists()) {\n\timportFolder.mkdirs()\n} \nsql.withBatch(20,\"\"\"REPLACE INTO Voters \n  (`county_code`,\n  `voter_id`,\n  `name_last`,\n  `name_suffix`,\n  `name_first`,\n  `name_middle`,\n  `suppress_address`,\n  `residence_address_line_1`,\n  `residence_address_line_2`,\n  `residence_city`,\n  `residence_state`,\n  `residence_zipcode`,\n  `mailing_address_line_1`,\n  `mailing_address_line_2`,\n  `mailing_address_line_3`,\n  `mailing_city`,\n  `mailing_state`,\n  `mailing_zipcode`,\n  `mailing_country`,\n  `gender`,\n  `race`,\n  `birth_date`,\n  `registration_date`,\n  `party_affiliation`,\n  `precinct`,\n  `precinct_group`,\n  `precinct_split`,\n  `precinct_suffix`,\n  `voter_status`,\n  `congressional_district`,\n  `house_district`,\n  `senate_district`,\n  `county_commission_district`, \n  `school_board_district`, \n  `daytime_area_code`,\n  `daytime_phone_number`,\n  `daytime_phone_extension`,\n  `export_date`) VALUES(\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\tSTR_TO_DATE(?,'%m/%d/%Y'),\n\tSTR_TO_DATE(?,'%m/%d/%Y'),\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\t?,\n\tSTR_TO_DATE(?,'%Y%m%d'))\n\"\"\") { ps ->                 \n\timportFolder.eachDirRecurse() { dir ->\n\t\tdir.eachFileMatch(~/.*Extract.zip/) { file -> \n\t\t\tdef zipFile = new java.util.zip.ZipFile(file)\n\t\t\tzipFile.entries().each { voterEntry ->\n\t\t\t\tdef modificationTime = (new Date(voterEntry.getTime())).format(\"yyyyMMdd\")\n\t\t\t\tprintln \"${modificationTime} Mod Time\"\n\t\t\t\tprintln \"Entry is ${voterEntry.name}\"\n\t\t\t\t(new BufferedReader(new InputStreamReader(zipFile.getInputStream(voterEntry), \"UTF-8\"))).eachLine { line ->\n\t\t\t\t\tline.toCsvReader(['separatorChar': '\\t']).eachLine { tokens ->\n\t\t\t\t\t\tps.addBatch(tokens + [modificationTime])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\t\n}",
  "class": "edu.usf.RuleChains.Groovy"
}